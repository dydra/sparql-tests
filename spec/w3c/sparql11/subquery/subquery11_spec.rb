# coding: utf-8
#
require 'spec_helper'

# Auto-generated by build_w3c_tests.rb
#
# sq11 - Subquery limit per resource
# This query limits results per number of orders, rather than by number of rows
# /Users/ben/Repos/dydra/tests/tests/sparql11-tests/data-sparql11/subquery/sq11.rq
#
# This is a W3C test from the DAWG test suite:
# http://www.w3.org/2001/sw/DataAccess/tests/r2#subquery11
#
# This test is approved: 
# 
#
describe "W3C test" do
  context "subquery" do
    before :all do
      @data = %q{
@prefix : <http://www.example.org> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .


:order1 a :Order; :hasItem 
    [ :amount 2 ; rdfs:label "Ice Cream" ; :price 4 ],
    [ :amount 2 ; rdfs:label "Pizza" ; :price 10 ],
    [ :amount 1 ; rdfs:label "Wine" ; :price 8 ].

:order2 a :Order; :hasItem 
    [ :amount 3 ; rdfs:label "Ice Cream" ; :price 4 ],
    [ :amount 2 ; rdfs:label "Pasta" ; :price 8 ],
    [ :amount 3 ; rdfs:label "Soft Drink" ; :price 6 ].

:order3 a :Order; :hasItem 
    [ :amount 1 ; rdfs:label "Sandwich" ; :price 3 ],
    [ :amount 1 ; rdfs:label "Soft Drink" ; :price 2 ].

:order4 a :Order; :hasItem 
    [ :amount 1 ; rdfs:label "Bagel" ; :price 3.5 ],
    [ :amount 1 ; rdfs:label "Soft Drink" ; :price 2 ].

}
      @query = %q{
# return labels of items for the first 2 orders

PREFIX : <http://www.example.org>
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>

SELECT ?L
WHERE {
 ?O :hasItem [ rdfs:label ?L ] .
 {
 SELECT DISTINCT ?O  
 WHERE { ?O a :Order }
 ORDER BY ?O
 LIMIT 2
 }
} ORDER BY ?L


}
    end

    example "sq11 - Subquery limit per resource", :status => 'unverified', :w3c_status => 'unapproved' do
    
      graphs = {}
      graphs[:default] = { :data => @data, :format => :ttl}


      repository = 'subquery-subquery11'
      expected = [
          { 
              :L => RDF::Literal.new('Ice Cream' ),
          },
          { 
              :L => RDF::Literal.new('Ice Cream' ),
          },
          { 
              :L => RDF::Literal.new('Pasta' ),
          },
          { 
              :L => RDF::Literal.new('Pizza' ),
          },
          { 
              :L => RDF::Literal.new('Soft Drink' ),
          },
          { 
              :L => RDF::Literal.new('Wine' ),
          },
      ]


      sparql_query(:graphs => graphs, :query => @query,       # unordered comparison in rspec is =~
                   :repository => repository, :form => :select).should =~ expected
    end
  end
end
