require 'sparql/spec/models'
require 'sparql/client'


dest_dir = ENV['DEST_DIR'] || File.join(File.expand_path(File.dirname(__FILE__)), '..', '..', '..', 'spec', 'w3c')
puts "saving to #{dest_dir}"

begin Dir.mkdir(dest_dir) rescue nil end

tests.each do |test|

  filename = File.basename(File.dirname(repository)) + '-' + File.basename(repository)

  query_data = IO.read(test.action.query_file.path)
  if query_data =~ /(ASK|CONSTRUCT|DESCRIBE|SELECT)/
    query_type = $1
  else
    raise "Couldn't determine query type for #{test.name}"
  end

  results_snippet = results_snippet_for(test)

  File.open(filename, "w+") do |f|
    f.write %Q{
# Auto-generated by sparql/builder.rb

describe "W3C test #{test.name}" do
  before :all do
    @data = %q{
call(test.action.test_data.path, test_file) 
#{IO.read(test.action.test_data.path)}
}
    @query = %{
#{IO.read(test_file)}
}
  end

  it "passes" do
   sparql_query(@data, @query).should == results
    
  end
end
}
  end
end

def results_snippet_for(test)
  query_data = IO.read(test.action.query_file.path)
  if query_data =~ /(ASK|CONSTRUCT|DESCRIBE|SELECT)/
    query_type = $1
  else
    raise "Couldn't determine query type for #{test.name}"
  end
  case query_type
    when 'ASK'
      ask_results_snippet(test)
    when 'SELECT'
      select_results_snippet(test)
    when 'DESCRIBE', 'CONSTRUCT'
      describe_results_snippet(test)
  end
end

def select_results_snippet(test)
  SPARQL::Client.new("").parse_xml_bindings(File.read(test.result.path)).map { |result| result.to_hash }).inspect
end

def ask_results_snippet(test)
end

def describe_results_snippet(test)
end


exit

share_as :A_SPARQL_Engine do
  
  before :all do
    #raise "@setup must be a proc to load repository data" unless @setup.respond_to?(:call) 
    raise "@query must be a proc to load repository data" unless @query.respond_to?(:call) 
  end

  after :each do
    @teardown.call unless @teardown.nil?
  end

  tests.each do |test|
    it "should pass #{test.name}" do
      # this should be in a before :each, but this is rough to do when creating tests automagically
      puts "CREATE=1 DEBUG=1 MANIFEST=#{test.manifest} bundle exec spec -bcfn -s \"SPOCQ should pass #{test.name}\" #{ARGV.last}"
      log "Using text data file " + test.action.test_data.path unless test.action.test_data.nil?
      pending "Not testing graphs just yet" if test.action.test_data.nil?
      log "Using query file " + test_file = File.expand_path(test.action.query_file.path.sub(/\..*/,".ssf"))
      pending "This test does not have an SSF form" unless File.exists?(test_file)

      # CONSTRUCT
      if test.action.query_string.match('CONSTRUCT')
        result = @query.call(test.action.test_data.path, test_file) 
        expected = RDF::Repository.load(test.result.path)
        #puts result
        #puts "**EXPECTED**"
        #puts expected
        result.should_be isomorphic_with expected
      # ASK
      elsif test.action.query_string.match('ASK')
        result = @query.call(test.action.test_data.path, test_file)
        boolean = if File.extname(test.result.path) == '.srx'
          SPARQL::Client.new("").parse_xml_bindings(File.read(test.result.path))
        else
          Spira.add_repository!(:results, RDF::Repository.load(test.result.path))
          ResultBindings.each.first.boolean
        end
        boolean.should == result
      # SELECT
      elsif test.action.query_string.match('SELECT')
        expected_repository = RDF::Repository.new 
        Spira.add_repository!(:results, expected_repository)
        expected = if File.extname(test.result.path) == '.srx'
          ResultBindings.for_solutions(SPARQL::Client.new("").parse_xml_bindings(File.read(test.result.path)).map { |result| result.to_hash })
        else
          expected_repository.load(test.result.path)
          ResultBindings.each.first.solutions.to_a
        end
        # data in tests has this useless predicate and generated repos don't.
        expected_repository.delete(:predicate => RS.resultVariable) 
        result = @query.call(test.action.test_data.path, test_file) 

        log puts "for #{test.name}:"
        results_repository = RDF::Repository.new
        Spira.add_repository!(:results, results_repository)

        opts = {}
        opts[:index] = test.manifest =~ /(sort|solution-seq)\/manifest.ttl/

        result_bindings = ResultBindings.for_solutions(result, opts)
       
        log "RESULT output for SELECT query (converted to W3C test output format)"
        log RDF::Writer.for(:ntriples).dump(results_repository)
        log "EXPECTED"
        log RDF::Writer.for(:ntriples).dump(expected_repository)

        log "RESULT binding output"
        Spira.add_repository(:results, results_repository)
        ResultBindings.pretty_print if ENV['DEBUG']
        log "EXPECT binding output"
        Spira.add_repository(:results, expected_repository)
        ResultBindings.pretty_print if ENV['DEBUG']

        results_repository.should be_isomorphic_with expected_repository
      end
    end
  end

end


